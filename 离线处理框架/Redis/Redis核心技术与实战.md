# Redis核心技术与实战

## 一、基本架构：一个键值数据库

### 1、存储的数据类型

#### 1.SimpleKV

1. key仅支持String类型。
2. value支持基本数据类型。 

#### 2.Redis支持的类型

1. key
2. value：Memcached 支持的 value 类型仅为 String 类型，而 Redis 支持的 value 类型包括了 String、哈希表、列表、集合等。

Redis能够在实际业务场景中得到广泛的应用，就得益于支持多样化类型的value。

从使用的角度来说，不同 value 类型的实现，不仅可以支撑不同业务的数据需求，而且也隐含着不同数据结构在性能、空间效率等方面的差异。

### 2、数据的操作

- PUT：新写入或更新一个 key-value 对；

- GET：根据一个 key 读取相应的 value 值；

- DELETE：根据一个 key 删除整个 key-value 对。

#### 1.键值对保存在内存还是外存

- 存的好处是读写很快，毕竟内存的访问速度一般都在百 ns 级别。但是，潜在的风险是一旦掉电，所有的数据都会丢失。
- 外存，虽然可以避免数据丢失，但是受限于磁盘的慢速读写（通常在几 ms 级别），键值数据库的整体性能会被拉低。

如何进行设计选择，需要根据键值数据库的主要应用场景。

### 3、架构

![](.\images\ec18bf4b8afef2fa8b99af252d95a2d5.webp)

#### 1.访问模式

1. **通过函数库调用方式供外部应用使用。**比如，上图中的 libsimplekv.so，就是以动态链接库的形式链接到我们自己的程序中，提供键值存储功能；
2. **通过网络框架以 Socket 通信的形式对外提供键值对操作**。这种形式可以提供广泛的键值存储服务，网络框架包括Socket Server和协议解析。

RocksDB以动态链接库的形式使用，而Memcached 和Redis则是通过网络框架访问。

网络访问的问题：

​	如果一个线程既要处理网络连接、解析请求、又要完成数据存取，一旦某一步操作发生阻塞，整个线程就会阻塞住，就会降低系统响应速度。

​	如果使用多线程就存在不同线程之间访问共享资源，那又会产生线程竞争，也会影响系统效率。

### 4、如何定位键值对的位置(索引模块)

#### 1.索引类型

常见的有哈希表、B+ 树、字典树等。

不同的索引结构在性能、空间消耗、并发控制等方面具有不同的特征。

Memcached 和 Redis 采用哈希表作为 key-value 索引，而 RocksDB 则采用跳表作为内存中 key-value 的索引。

内存键值数据库（例如 Redis）采用哈希表作为索引，很大一部分原因在于，其键值数据基本都是保存在内存中的，而**内存的高性能随机访问特性**可以很好地与哈希表 O(1) 的操作复杂度相匹配。

#### 2.不同操作的具体逻辑

1. SimpleKV

- 对于 GET/SCAN 操作而言，此时根据 value 的存储位置返回 value 值即可；
- 对于 PUT 一个新的键值对数据而言，SimpleKV 需要为该键值对分配内存空间；
- 对于 DELETE 操作，SimpleKV 需要删除键值对，并释放相应的内存空间，这个过程由分配器完成。

### 5、如何实现重启后快速提供服务

#### 1.SimpleKV

1. SimpleKV 采用了常用的内存分配器 glibc 的 malloc 和 free，因此，SimpleKV 并不需要特别考虑内存空间的管理问题。但是glibc的分配器在处理随机的大小内存块分配时，表现并不好，一旦键值规模过大就会造成严重的内存碎片问题。
2. SimpleKV 的存储模块中增加了持久化功能，鉴于磁盘管理要比内存管理复杂，SimpleKV 就直接采用了文件形式，将键值数据通过调用本地文件系统的操作接口保存在磁盘上。此时，SimpleKV 只需要考虑何时将内存中的键值数据保存到文件中，就可以了。
3. 保存的时期
   1. 对于每个键值对，SimpleKV都会对其进行落盘保存，虽然可靠，但每次都要写盘性能较受影响。
   2. SimpleKV 只是周期性地把内存中的键值数据保存到文件中，这样可以避免频繁写盘操作的性能影响。但是，一个潜在的代价是 SimpleKV 的数据仍然有丢失的风险。

#### 2.Redis

1. 多种分配器。
2. Redis的持久化，AOF和RDB。

### 6、总结

![](.\images\30e0e0eb0b475e6082dd14e63c13ed44.jpg)

- Redis 主要通过网络框架进行访问，而不再是动态库了，这也使得 Redis 可以作为一个基础性的网络服务进行访问，扩大了 Redis 的应用范围。
- Redis 数据模型中的 value 类型很丰富，因此也带来了更多的操作接口，例如面向列表的 LPUSH/LPOP，面向集合的 SADD/SREM 等。在下节课，我将和你聊聊这些 value 模型背后的数据结构和操作效率，以及它们对 Redis 性能的影响。
- Redis 的持久化模块能支持两种方式：日志（AOF）和快照（RDB），这两种持久化方式具有不同的优劣势，影响到 Redis 的访问性能和可靠性。
- SimpleKV 是个简单的单机键值数据库，但是，Redis 支持高可靠集群和高可扩展集群，因此，Redis 中包含了相应的集群功能支撑模块。

## 二、数据结构

![](.\images\8219f7yy651e566d47cc9f661b399f01.webp)

### 1、键和值用什么结构组织

为了实现从键到值的快速访问，Redis 使用了一个哈希表来保存所有键值对。一个哈希表，其实就是一个数组，数组的每个元素称为一个哈希桶。哈希桶中的元素保存的并不是值的本身，而是指向具体的指针。

![](.\images\1cc8eaed5d1ca4e3cdbaa5a3d48dfb5f.webp)

全局哈希表：哈希表保存了所有的键值对。

### 2、哈希表操作变慢

哈希表的冲突问题和 rehash 可能带来的操作阻塞。

1.Redis解决哈希冲突的方式就是链式哈希。就是同一个哈希桶中的多个元素用一个链表来保存，它们之间依次用指针连接。

![](.\images\8ac4cc6cf94968a502161f85d072e428.webp)

问题：哈希冲突链上的元素只能通过指针逐一查找再操作，冲突链过长导致链上的元素查找耗时长，效率降低。

2.Redis 会对哈希表做 rehash 操作。rehash 也就是增加现有的哈希桶数量，让逐渐增多的 entry 元素能在更多的桶之间分散保存，减少单个桶中的元素数量，从而减少单个桶中的冲突。

为了使refresh操作更高效，Redis默认使用了两个全局哈希表：哈希表1和哈希表2。

- 给哈希表 2 分配更大的空间，例如是当前哈希表 1 大小的两倍；
- 把哈希表 1 中的数据重新映射并拷贝到哈希表 2 中；
- 释放哈希表 1 的空间。

我们就可以从哈希表 1 切换到哈希表 2，用增大的哈希表 2 保存更多数据，而原来的哈希表 1 留作下一次 rehash 扩容备用。

**注意**：

第二步涉及大量的数据拷贝，如果一次性把哈希表1中的数据迁移完，会造成Redis线程阻塞，无法服务其他请求。为了避免这个问题，Redis采用渐进式refresh。

第二步拷贝数据时，Redis 仍然正常处理客户端请求，每处理一个请求时，从哈希表 1 中的第一个索引位置开始，顺带着将这个索引位置上的所有 entries 拷贝到哈希表 2 中；等处理下一个请求时，再顺带拷贝哈希表 1 中的下一个索引位置的 entries。如下图所示：

![](.\images\73fb212d0b0928d96a0d7d6ayy76da0c.webp)

这样就巧妙地把一次性大量拷贝的开销，分摊到了多次处理请求的过程中，避免了耗时操作，保证了数据的快速访问。

### 3、集合数据的操作效率

集合类型的底层数据结构：整数数组、双向链表、哈希表、压缩列表、跳表。

- 整数数组和双向链表也很常见，它们的操作特征都是顺序读写，也就是通过数组下标或者链表的指针逐个元素访问，操作复杂度基本是 O(N)，操作效率比较低；
- 哈希表查找复杂度O(1).
- 压缩列表和跳表O(logN)

压缩列表在表头有三个字段 zlbytes、zltail 和 zllen，分别表示列表长度、列表尾的偏移量和列表中的 entry 个数；压缩列表在表尾还有一个 zlend，表示列表结束。查找第一和最后一个元素复杂度为O(1),其他元素为O(N)。

![](.\images\9587e483f6ea82f560ff10484aaca4a0.webp)

跳表增加多级索引，通过索引位置的几个跳转，实现数据的快速定位。

![](.\images\fb7e3612ddee8a0ea49b7c40673a0cf0.webp)

### 4、不同操作的复杂度

1. 单元素操作，指对单个元素的增删改查。这些操作的复杂度由底层的数据结构决定。
   1. Hash类：HGET、HSET、HDEL。
   2. Set类：SADD、SREM、SRANDMEMBER
2. 范围操作，是指集合类型中的遍历操作，可返回集合中所有的数据。复杂度为O(n)
   1. Hash类：HGETALL
   2. Set类：SMEMNERS
3. 统计操作，是指集合类型对集合中所有元素个数的记录。LLEN和SCARD。
4. 是指某些数据结构的特殊记录，例如压缩列表和双向链表都会记录表头和表尾的偏移量。
   1. List类型：LPOP、RPOP、LPUSH、RPUSH。

## 三、高性能IO模型

Redis 是单线程，主要是指 **Redis 的网络 IO 和键值对读写是由一个线程来完成**的，这也是 Redis 对外提供键值存储服务的主要流程。但 Redis 的其他功能，比如持久化、异步删除、集群数据同步等，其实是由额外的线程执行的。

### 1、Redis为什么使用单线程？

#### 1.多线程开销

- 优点：多线程可以提升系统能够同时处理的请求数，即吞吐率。
- 缺点：系统中常存在同时被多线程访问的共享资源，比如共享的数据结构。为了保证数据的准确性，就需要一定的机制去保证，从而造成额外的开销。

多线程编程模式面临的共享资源的并发访问控制问题，如果没有精细的设计，只是简单地采用一个粗粒度互斥锁，就会出现不理想的结果：即使增加了线程，大部分线程也在等待获取访问共享资源的互斥锁，并行变串行，系统吞吐率并没有随着线程的增加而增加。

### 2、单线程Redis为什么这么快？

- Redis大部分操作都在内存上完成的，采用了高效的数据结构，例如哈希表、跳表等。
- Redis采用了多路复用机制，使其在网络IO操作中能并发处理大量的客户端请求，实现高吞吐率。

#### 1.基本IO模型

![](.\images\e18499ab244e4428a0e60b4da6575bc9.webp)

在这里的网络 IO 操作中，有潜在的阻塞点，分别是 accept() 和 recv()。当 Redis 监听到一个客户端有连接请求，但一直未能成功建立起连接时，会阻塞在 accept() 函数这里，导致其他客户端无法和 Redis 建立连接。类似的，当 Redis 通过 recv() 从一个客户端读取数据时，如果数据一直没有到达，Redis 也会一直阻塞在 recv()。

socket网络模型支持非阻塞模式

- 非阻塞模式
- 基于多路复用的高性能I/O模型：Linux 中的 IO 多路复用机制是指一个线程处理多个 IO 流，就是我们经常听到的 select/epoll 机制。
  - 在 Redis 只运行单线程的情况下，该机制允许内核中，同时存在多个监听套接字和已连接套接字。内核会一直监听这些套接字上的连接请求或数据请求。一旦有请求到达，就会交给 Redis 线程处理，这就实现了一个 Redis 线程处理多个 IO 流的效果。
  - 为了在请求到达时能通知到 Redis 线程，select/epoll 提供了基于事件的回调机制，即针对不同事件的发生，调用相应的处理函数。这些事件会被放进一个事件队列，Redis 单线程对该事件队列不断进行处理。

### 3、Redis单线程处理IO请求性能瓶颈主要包括2个方面： 

1、任意一个请求在server中一旦发生耗时，都会影响整个server的性能，也就是说后面的请求都要等前面这个耗时请求处理完成，自己才能被处理到。耗时的操作包括以下几种： 

​	a、操作bigkey：写入一个bigkey在分配内存时需要消耗更多的时间，同样，删除bigkey释放内存同样会产生耗时；

​	 b、使用复杂度过高的命令：例如SORT/SUNION/ZUNIONSTORE，或者O(N)命令，但是N很大，例如lrange key 0 -1一次查询全量数据； 

​	c、大量key集中过期：Redis的过期机制也是在主线程中执行的，大量key集中过期会导致处理一个请求时，耗时都在删除过期key，耗时变长； 

​	d、淘汰策略：淘汰策略也是在主线程执行的，当内存超过Redis内存上限后，每次写入都需要淘汰一些key，也会造成耗时变长； 

​	e、AOF刷盘开启always机制：每次写入都需要把这个操作刷到磁盘，写磁盘的速度远比写内存慢，会拖慢Redis的性能； 

​	f、主从全量同步生成RDB：虽然采用fork子进程生成数据快照，但fork这一瞬间也是会阻塞整个线程的，实例越大，阻塞时间越久；

 2、并发量非常大时，单线程读写客户端IO数据存在性能瓶颈，虽然采用IO多路复用机制，但是读写客户端数据依旧是同步IO，只能单线程依次读取客户端的数据，无法利用到CPU多核。 

针对问题1，一方面需要业务人员去规避，一方面Redis在4.0推出了lazy-free机制，把bigkey释放内存的耗时操作放在了异步线程中执行，降低对主线程的影响。

 针对问题2，Redis在6.0推出了多线程，可以在高并发场景下利用CPU多核多线程读写客户端数据，进一步提升server性能，当然，只是针对客户端的读写是并行的，每个命令的真正操作依旧是单线程的。

## 四、AOF日志：宕机了Redis如何避免数据丢失

Redis主要的应用场景是作为缓存使用，因为可以充分利用内存高效的响应速度，当时服务器宕机就容易造成数据丢失。

Redis的持久化机制：AOF日志和RDB快照

### 1、AOF日志是如何实现的？

#### 1.写前日志（Write Ahead Log，WAL）

- 在实际写数据前，先把修改的数据记到日志文件中，以便故障进行恢复。

#### 2.Redis写日志

- Redis先执行命令，把数据写到内存，然后才记录日志。
- 为什么？
  - 传统数据库的日志，例如redo log（重做日志），记录的是修改后的数据，而AOF里记录的是Redis收到的每一条命令，这些命令以文本的形式保存。
  - 先让系统执行命令，只有命令执行成功了，才会被记录到日志中，否则系统就会直接向客户端报错，避免记录了错误的日志。
  - 先让系统执行命令后再记录到日志，不会阻塞当前的写操作。
- 缺点：
  - 如果刚执行完一个命令，还没来得及记录日志就宕机了，那么这个命令和相应的数据就有丢失的风险。如果此时 Redis 是用作缓存，还可以从后端数据库重新读入数据进行恢复，但是，如果 Redis 是直接用作数据库的话，此时，因为命令没有记入日志，所以就无法用日志进行恢复了。
  - AOF虽然避免了对当前命令阻塞，但可能会给下一个操作带来阻塞的风险。这是因为AOF日志也是在主线程中执行的，如果把文件写入磁盘时，磁盘写压力增大，就会导致写盘很慢，进而导致后续的操作无法执行。

#### 3.三种写策略

- Always：同步写回，每个写命令执行完，立马同步地将日志写回磁盘。
- Everysec：每秒写回，每个写命令执行完，只是先把日志写到AOF文件的内存缓冲区，每隔一秒把缓冲区的内容写入磁盘。
- No：操作系统控制的写回：每个写命令执行完，只是先把日志写到 AOF 文件的内存缓冲区，由操作系统决定何时将缓冲区内容写回磁盘。

三种写策略问题：

- “同步写回”可以做到基本不丢数据，但是它在每一个写命令后都有一个慢速的落盘操作，不可避免地会影响主线程性能；
- 虽然“操作系统控制的写回”在写完缓冲区后，就可以继续执行后续的命令，但是落盘的时机已经不在 Redis 手中了，只要 AOF 记录没有写回磁盘，一旦宕机对应的数据就丢失了；
- “每秒写回”采用一秒写回一次的频率，避免了“同步写回”的性能开销，虽然减少了对系统性能的影响，但是如果发生宕机，上一秒内未落盘的命令操作仍然会丢失。所以，这只能算是，在避免影响主线程性能和避免数据丢失两者间取了个折中。

![](.\images\72f547f18dbac788c7d11yy167d7ebf8.webp)

### 2、AOF性能问题

1. 系统文件本身大小限制，无法保存过大的文件；
2. 如果文件过大，之后再往里面追加命令记录，效率也会变低；
3. 如果发生宕机，AOF记录的命令要一个个重新执行，用于故障恢复，文件太大就会导致恢复过程缓慢。

#### 1、文件太大

1. 重写机制
   1. 重写机制具有“多变一”功能。所谓的“多变一”，也就是说，旧日志文件中的多条命令，在重写后的新日志中变成了一条命令。
   2. 虽然 AOF 重写后，日志文件会缩小，但是，要把整个数据库的最新数据的操作日志都写回磁盘，仍然是一个非常耗时的过程。
2. AOF重写会阻塞吗？
   1. AOF 日志由主线程写回不同，重写过程是由后台子进程 bgrewriteaof 来完成的，这也是为了避免阻塞主线程，导致数据库性能下降。
   2. 一个拷贝：每次重写时，主线程fork出后台的bgrewriteaof子进程，fork会把主线程的内存拷贝一份给bgrewriteaof子进程，这里面包含了数据库的最新数据。然后，bgrewriteaof 子进程就可以在不影响主线程的情况下，逐一把拷贝的数据写成操作，记入重写日志。
   3. 两处日志：因为主线程未阻塞，仍然可以处理新来的操作。
      1. 如果有写操作，第一处日志就是指正在使用的 AOF 日志，Redis 会把这个操作写到它的缓冲区。这样一来，即使宕机了，这个 AOF 日志的操作仍然是齐全的，可以用于恢复。
      2. 是指新的 AOF 重写日志。这个操作也会被写到重写日志的缓冲区。这样，重写日志也不会丢失最新的操作。等到拷贝数据的所有操作记录重写完成后，重写日志记录的这些最新操作也会写入新的 AOF 文件，以保证数据库最新状态的记录。此时，我们就可以用新的 AOF 文件替代旧文件了。

![](.\images\6b054eb1aed0734bd81ddab9a31d0be8.webp)

## 五、内存快照：快速恢复

AOF日志记录的是操作而不是数据，在恢复时需要一条条执行进行恢复，数据恢复就会特别慢。RDB时内存快照，将某一时刻的状态以文件的形式写到磁盘。

### 1、给哪些内存做快照

Redis 的数据都在内存中，为了提供所有数据的可靠性保证，它执行的是全量快照，也就是说，把内存中的所有数据都记录到磁盘中。当数据太大时，快照的操作也会比较慢，Redis是单线程，应尽量避免阻塞主线程。

#### 1.操作

1. save：在主线程中执行，会导致阻塞。
2. bgsave：创建一个子进程，专门用于写入 RDB 文件，避免了主线程的阻塞，这也是 Redis RDB 文件生成的默认配置。

### 2、快照时修改数据

在快照时主线程并没有阻塞，可以接受正常的请求，但为了保证快照的完整性，它只能处理读操作，，不能修改正在执行的快照的数据。

#### 1.Copy-On-Write

1. Redis 就会借助操作系统提供的写时复制技术（Copy-On-Write, COW），在执行快照的同时，正常处理写操作。
2. bgsave 子进程是由主线程 fork 生成的，可以共享主线程的所有内存数据。bgsave 子进程运行后，开始读取主线程的内存数据，并把它们写入 RDB 文件。

![](.\images\a2e5a3571e200cb771ed8a1cd14d5558.jpg)

### 3、快照的时机

#### 1.频繁快照的危害

1. 频繁将全量数据写入磁盘，会给磁盘带来很大压力，多个快照竞争有限的磁盘带宽，前一个快照还没有做完，后一个又开始做了，容易造成恶性循环。
2. bgsave 子进程需要通过 fork 操作从主线程创建出来。虽然，子进程在创建后不会再阻塞主线程，但是，fork 这个创建过程本身会阻塞主线程，而且主线程的内存越大，阻塞时间越长。如果频繁 fork 出 bgsave 子进程，这就会频繁阻塞主线程了（所以，在 Redis 中如果有一个 bgsave 在运行，就不会再启动第二个 bgsave 子进程）。

#### 2.混用使用AOF日志和内存快照

简单来说，内存快照以一定的频率执行，在两次快照之间，使用 AOF 日志记录这期间的所有命令操作。

第二次做全量快照时就可以将上一次的AOF文件删除。

![](.\images\e4c5846616c19fe03dbf528437beb320.webp)

### 4、使用建议

- 数据不能丢失时，内存快照和 AOF 的混合使用是一个很好的选择；
- 如果允许分钟级别的数据丢失，可以只使用 RDB；
- 如果只用 AOF，优先使用 everysec 的配置选项，因为它在可靠性和性能之间取了一个平衡。

## 六、数据同步：主从库如何实现数据一致性

Redis的可靠性

1. 数据尽量少丢失
2. 服务尽量少中断

Redis 提供了主从库模式，以保证数据副本的一致，主从库之间采用的是读写分离的方式。

- 读操作：主库、从库都可以接收。
- 写操作：首先到主库执行，主库将写操作同步到从库。

### 1.为什么采用读写分离的方式？

1. 假设主从库都能接收客户端的读写操作，就会导致数据不一致，就要通过加锁、实例间协商是否完成修改等一系列操作，但这会带来巨额的开销。

### 2.主从库如何进行数据同步？

1. 第一次同步

当我们启动多个 Redis 实例的时候，它们相互之间就可以通过 replicaof（Redis 5.0 之前使用 slaveof）命令形成主库和从库的关系，之后会按照三个阶段完成数据的第一次同步。

![](.\images\63d18fd41efc9635e7e9105ce1c33da1.webp)

```shell
replicaof 172.16.19.3 6379
#172.16.19.3 为主库
```

- 第一阶段是主从库建立连接、协商同步过程，主要是为了全量复制做准备。主库确认回复后就可以开始同步数据。从库给主库发送 psync 命令，表示要进行数据同步，主库根据这个命令的参数来启动复制。psync 命令包含了主库的 runID 和复制进度 offset 两个参数。
  - runID：每个Redis实例启动时都会自动生成的一个随机ID，用来标记唯一的实例。第一次复制为“？”。
  - offset：第一次复制设为-1。
  - FULLRESYNC 响应表示第一次复制采用的全量复制，也就是说，主库会把当前所有的数据都复制给从库。
- 主库将所有数据同步给从库。从库收到数据后，在本地完成数据加载。这个过程依赖于内存快照生成的 RDB 文件。
  - 主库执行bgsave命令，生成RDB文件，将文件发给从库。
  - 从库接收到 RDB 文件后，会先清空当前数据库，然后加载 RDB 文件。这是因为从库在通过 replicaof 命令开始和主库同步前，可能保存了其他数据。为了避免之前数据的影响，从库需要先把当前数据库清空。
  - 主库进行数据同步的时候不会被阻塞，仍然可以正常接收请求，否则Redis的服务就中断。
  - 同步过程中的写操作不会记录到RDB文件中，为了保证主从库的数据一致性，主库会在内存中用专门的replication buffer记录RDB文件生成后所收到的所有写操作。
- 主库会把第二阶段执行过程中新收到的写命令，再发送给从库。具体的操作是，当主库完成 RDB 文件发送后，就会把此时 replication buffer 中的修改操作发给从库，从库再重新执行这些操作。这样一来，主从库就实现同步了。

### 3.全量复制时主库的压力：主从级联模式

全量复制时主库的耗时操作：生成RDB文件和传输RDB文件。

如果从库数量很多都要和主库进行全量复制，会导致主库忙于fork子进程生成RDB文件，进行数据全量同步。fork 这个操作会阻塞主线程处理正常请求，从而导致主库响应应用程序的请求速度变慢。

通过“主 - 从 - 从”模式将主库生成 RDB 和传输 RDB 的压力，以级联的方式分散到从库上。

1. 部署主从集群时，手动选择一个从库，用于级联其他的从库，然后再选一些从库（例如三分之一的从库），在这些从库下执行如下命令，让他们和刚才所选的从库，建立起主从关系。

```
replicaof  所选从库的IP 6379
```

1. 这些从库就会知道，在进行同步时，不用再和主库进行交互了，只要和级联的从库进行写操作同步就行了，这就可以减轻主库上的压力

![](.\images\403c2ab725dca8d44439f8994959af45.webp)

一旦主从库完成了全量复制，它们之间就会一直维护一个网络连接，主库会通过这个连接将后续陆续收到的命令操作再同步给从库，这个过程也称为**基于长连接的命令传播**，可以避免频繁建立连接的开销。

但会存在网络断联或阻塞的风险，导致主从库数据不一致，客户端读到旧数据。

### 4.主从库间网络断了

Redis2.8之前，如果主从库在命令传播时出现网络闪断，那么主从库重新进行一次全量复制，开销非常大。

Redis2.8之后，主从库采用增量复制的方式继续同步。

#### 1.主从库如何保持同步？repl_backlog_buffer

1. 当主从库断连后，主库会把断连期间收到的写操作命令，写入 **replication buffer**，同时也会把这些操作命令也写入 **repl_backlog_buffer** 这个缓冲区。
   1. repl_backlog_buffer 是一个环形缓冲区，主库会记录自己写到的位置，从库则会记录自己已经读到的位置。
   2. 刚开始，主从库读写的位置在一起。主库写偏移量：master_repl_offset；从库读偏移量：slave_repl_offset。
   3. 主从库的连接恢复之后，从库首先会给主库发送 psync 命令，并把自己当前的 slave_repl_offset 发给主库，主库会判断自己的 master_repl_offset 和 slave_repl_offset 之间的差距。在网络断联阶段，主库有可能收到新的写操作命令，所以一般master_repl_offset 大于slave_repl_offset 。将中间的操作命令同步就行。

![](.\images\20e233bd30c3dacb0221yy0c77780b16.webp)

#### 2.repl_backlog_buffer缓冲区写满

如果从库的读取速度比较慢，就有可能导致从库还未读取的操作被主库新写的操作覆盖了，这会导致主从库间的数据不一致。

1. 调整repl_backlog_size这个参数，这个参数和所需的缓冲空间大小有关。缓冲空间的计算公式是：缓冲空间大小 = 主库写入命令速度 * 操作大小 - 主从库间网络传输命令速度 * 操作大小。一般repl_backlog_size = 缓冲空间大小 * 2。
2. 在请求并发量增加的时候也需要适当 提高repl_backlog_size 值。

## 七、哨兵机制（预防主库挂掉）

为了防止主库挂掉，需要将从库切换成主库。

问题：

1. 主库真的挂了？-- 监控主库的运行状态，判断主库是否客观下线
2. 选择哪个从库作为主库？-- 在主库客观下线后，选取新主库
3. 怎么把新库的相关信息通知给从库和客户端？-- 选出新主库后，通知从库和客户端

### 1、基本流程

![](.\images\efcfa517d0f09d057be7da32a84cf2a1.webp)

### 2、监控

#### 1、哨兵的决策

1. 在监控任务中，哨兵需要判断主库是否处于下线状态；
2. 在选主任务中，哨兵也要决定选择哪个从库实例作为主库。

#### 2、主观下线和客观下线

- 哨兵进程会使用 PING 命令检测它自己和主、从库的网络连接情况，用来判断实例的状态。如果哨兵发现主库或从库对 PING 命令的响应超时了，那么，哨兵就会先把它标记为“主观下线”。
  - 如果检测的是从库，哨兵简单地标记为“主管下线”，因为从库的下线对集群的对外服务影响不大。
  - 检测主库：哨兵集群进行判断，少数服从多数。

### 3、选取新主库(筛选+打分)

#### 1、筛选

- 检查从库的当前在线状态。
- 判断网络的连接状态。

#### 2、打分

- 优先级最高的从库得分高。
- 和旧主库同步程度最接近的从库得分高。
  - 主库master_repl_offset主库记录当前最新写操作repl_backlog_buffer中的位置。
  - 从库会用 slave_repl_offset 这个值记录当前的复制进度。
- ID 号小的从库得分高。

## 八、哨兵集群

### 1、基于pub/sub机制的哨兵集群组成

- 和主库建立连接，就可以在主库发布消息，比如自己的连接信息（IP/端口）。
- 订阅其他哨兵发布的消息。
- 区别不同的消息将会通过频道的形式。只有在同一个频道内的应用才可以通过发布消息进行信息交换。

### 2、哨兵和从库连接

- 哨兵向主库发送INFO命令。
- 主库把从库列表返回给哨兵，哨兵根据从库列表和从库建立连接，并持续监控。

### 3、哨兵如何监控（基于pub/sub机制的客户端事件通知）

- 哨兵就是一个运行在特定模式下的 Redis 实例，只不过它并不服务请求操作，只是完成监控、选主和通知的任务。
- 每个哨兵实例也提供 pub/sub 机制，客户端可以从哨兵订阅消息。
- 哨兵提供的消息订阅频道有很多，不同频道包含了主从库切换过程中的不同关键事件。

![](.\images\4e9665694a9565abbce1a63cf111f725.webp)

### 4、由那个哨兵进行主从切换

类似于Zookeeper的leader选举

![](.\images\e0832d432c14c98066a94e0ef86af384.webp)

哨兵所需要的赞成票在配置文件中的 quorun 配置项设定。

## 九、切片集群

### 1、单实例Redis问题

- 在使用RDB持久化时，数据量越大,fork操作的时间也越大。

### 2、解决单实例Redis问题

- 使用切片集群，也就是多实例Redis，每个实例进行持久化时的时间就会比较小，fork线程也不会带来较大的阻塞。

### 3、如何保存更多的数据

- 纵向扩展
  - 实施简单但易受到硬件和成本的限制。
- 横向扩展
  - 多个实例。
  - 在面向百万、千万级别的用户规模时，横向扩展的 Redis 切片集群会是一个非常好的选择。

### 4、数据切片和实例对应分布关系

- 3.0开始官方提供了一个Redis Cluster的方案，用于实现切片集群。其中采用了Hash Slot，一个切片集群有16384个slot，类似于分区，每个键值都根据他的key映射到哈希槽中。

  - 根据键值对的key，按照CRC16算法计算一个16bit的值，然后再用这个16bit值对16384取模，得到0~16384范围内的模数，每个代表一个相应编号的哈希槽。

  ```
  cluster create #平均分配哈希槽
  cluster meet	#手动建立实例间的连接，形成集群。
  cluster addslots #指定每个实例上的哈希槽
  ```

  在手动分配哈希槽时，需要把 16384 个槽都分配完，否则 Redis 集群无法正常工作。

  

  ### 5、客户端定位数据

  防水密封

  
  
  ## 十、String 类型
  
  ### 1、String类型内存占用
  
  ![](.\images\1.PNG)

int编码在Redis中内存的占用：

![](.\images\b6cbc5161388fdf4c9b49f3802ef53e7.webp)

8B+8B+8B+16B+16B=56B

Redis会使用jemalloc进行内存分配，它会找一个比申请内存N大，但最接近N的2的幂次数作为分配的空间，这样可以减少频繁分配的次数。

### 2、如何节省内存

![](.\images\f6d4df5f7d6e80de29e2c6446b02429f.webp)

- zlbytes：列表长度
- zltail：列表尾偏移量
- zllen：列表中entry个数

- prev_len，表示前一个 entry 的长度。prev_len 有两种取值情况：1 字节或 5 字节。取值 1 字节时，表示上一个 entry 的长度小于 254 字节。虽然 1 字节的值能表示的数值范围是 0 到 255，但是压缩列表中 zlend 的取值默认是 255，因此，就默认用 255 表示整个压缩列表的结束，其他表示长度的地方就不能再用 255 这个值了。所以，当上一个 entry 长度小于 254 字节时，prev_len 取值为 1 字节，否则，就取值为 5 字节。
- len：表示自身长度，4字节。
- encoding：表示编码方式，1字节。
- content：保存实际数据。

Redis 基于压缩列表实现了 List、Hash 和 Sorted Set 这样的集合类型，这样做的最大好处就是节省了 dictEntry 的开销。

存储Long类型对象所占内存大小：（1+4+1+8=14B）

### 3、如何用集合类型保存单值的键值对

1. 二级编码

2. ，Hash 类型设置了用压缩列表保存数据时的两个阈值，一旦超过了阈值，Hash 类型就会用哈希表来保存数据了。

   1. hash-max-ziplist-entries：表示用压缩列表保存时哈希集合中的最大元素个数。
   2. hash-max-ziplist-value：表示用压缩列表保存时哈希集合中单个元素的最大长度。 
   3.   

    0 
