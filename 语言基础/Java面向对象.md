# 继承

一、概念

1. Java不允许多继承，支持多层继承。
2. 提高了代码的复用性，提供了多态的前提。

二、子父类成员变量的特点

1. 父类的成员变量是非私有的，子类中可以直接访问；若父类中的成员变量私有了，子类是不能直接访问的。
2. 若子类和父类出现同名的变量时，必须使用关键字super来完成，super用来表示当前对象中包含的父类对象空间的引用。

三、子类中成员方法特点

1. 重写：一摸一样的方法。方法的返回值类型 方法名 参数列表都要一样。

   ```
   super.父类中的成员方法。
   ```

四、重载与重写

- 重载

1. 权限修饰符(public private 默认):无关。

2. 方法名:重载的两个方法的方法名必须相同

3. 形参列表:

   - 形参类型的顺序不同

   - 形参的个数不同

   - 形参的类型不同

     三者至少满足一个

     返回值类型:重载与返回值类型无关

- 重写

1. 权限修饰符(public private 默认): 子类方法的权限>=父类的方法的权限
2. 方法名: 子类方法和父类方法必须相同
3. 形参列表: 子类方法和父类方法的形参列表必须相同
4. 返回值类型:基本类数据类型:必须相同
5. 引用数据类型:子类方法的返回值类型和父类方法的返回值类型相同，或者子类方法的返回值类型是父类方法的返回值类型的 子类

# 抽象类

一、抽象类特点

1. 抽象类一定是个父类？ 是的，因为不断抽取而来的。
2. 抽象类中是否可以不定义抽象方法。是可以的，那这个抽象类的存在到底有什么意义呢？不让该类创建对象,方法可以直接让子类去使用。
3. 抽象关键字abstract不可以和哪些关键字共存？
   1. private
   2. final
   3. static

# 接口

一、概念

1. 接口是功能的集合，同样看作是一种数据类型，是比抽象类更为抽象的类。
2. 接口只描述所应该具备的方法，并没有具体实现，具体的实现由接口的实现类完成。这样实现了功能的定义与实现分离。
3. 请记住：一切事物均有功能，即一切事物均有接口。

二、接口定义

```
public interface 接口名{
	抽象方法1;
	抽象方法2;
	抽象方法3;
	//接口的方法均为公共访问的抽象方法。
	//接口中无法定义普通的成员变量。
	//定义接口所在的仍为.java文件，虽然声明时使用的为interface关键字的编译后仍然会产生.class文件。
}
```

三、类接口实现

```
class 类 implements 接口{
	重写接口中方法;
}
```

四、接口中成员变量的特点

1. 接口中可以定义变量，但是变量必须有固定的修饰符修饰，public static final，所以接口中的变量也称之为常量，其值不能改变。
2. 接口中可以定义方法。
3. 接口中不可以创建对象。
4. 子类必须覆盖掉接口中所有的方法后，子类才可以实例化。否则子类是一个抽象类。

五、接口多实现

1. 解决多继承的弊端。将多继承这种机制在java中通过多实现完成了。
2. 多继承时，当多个父类中有相同功能时，子类调用会产生不确定性。其实核心原因就是在于多继承父类中功能有主体，而导致调用运行时，不确定运行哪个主体内容。为什么多实现能解决了呢？因为接口中的功能都没有方法体，由子类来明确。

六、类继承类的同时实现接口

```
class A extends B implements C{
	
}
```

七、接口的多继承

```
interface extends A,B,C{

}
```

八、接口的思想

1. 接口的出现扩展了功能。
2. 接口其实就是暴漏出来的规则。
3. 接口的出现降低了耦合性，即设备与设备之间实现了解耦。

# 多态

一、特点

1. 最终多态体现为父类引用变量可以指向子类对象。
2. 多态的前提是必须有子父类关系或者类实现接口关系，否则无法完成多态。
3. 在使用多态后的父类引用变量调用方法时，会调用子类重写后的方法。

二、定义与使用格式

1. 父类的引用指向子类的对象。
2. 接口 变量名 = new 接口实现类();

三、成员特点

当父类和在子类中出现同名的成员变量时，多态调用该变量。

1. 编译时期：参考引用变量所属的类，如果没有类中没有调用的方法，编译失败。
2. 运行时期：参考引用变量所指的对象所属的类，并运行对象所属类中的成员方法。

四、instanceof关键字

```
boolean b = 对象 instanceof 数据类型;
```

五、多态--转型

1. 向上转型：当有子类对象赋值给一个父类引用时，便是向上转型，多态本身就是向上转型的过程。		
   1. 使用格式：父类类型 变量名 = new 子类类型(); 如：Person p = new Student();
2. 向下转型：一个已经向上转型的子类对象可以使用强制类型转换的格式，将父类引用转为子类引用，这个过程是向下转型。如果是直接创建父类对象，是无法向下转型的！
   1. 使用格式：子类类型 变量名 = (子类类型) 父类类型的变量; 如:Student stu = (Student) p; //变量p 实际上指向Student对象。

六、类与类，类与接口，接口与接口之间的关系

1. 类与类之间：继承关系，单继承，可以是多层继承
2. 类与接口之间: 实现关系，单实现，也可以多实现
3. 接口与接口之间：继承关系，单继承，也可以是多继承
4. Java中的类可以继承一个父类的同时，实现多个接口

# final关键字

一、继承的出现提高了代码的复用性，有些类的描述不想被继承，或者有些类中的部分方法功能是固定的，不想让子类重写。

二、final的特点

1. final修饰类不可以被继承，但可以继承其他类。
2. final修饰的方法不可以被覆盖，若父类没有被final修饰的方法，子类覆盖后可以加final。
3. final修饰的变量称为常量，这些变量只能赋值一次。
4. 引用类型的变量值为对象地址值，地址值不能更改，但是地址内的对象属性值可以更改。
5. 修饰成员变量，需要在创建对象前赋值，负责报错。

# static关键字

一、可以不创建对象使用static修饰的成员变量。

- 类名.静态成员变量名
- 类名.静态成员方法名(参数)

二、static注意事项

- 静态内容优于对象存在，只能访问静态，不能使用this/super。静态修饰的内容存在于静态区。
- 同一个类中，静态成员只能访问静态成员。

三、定义静态常量

1. 格式

```
public static final 数据类型 变量名 = 值;
```

 	2. 注意

- 接口中的每个成员变量默认使用public static final修饰。
- 所有接口中的成员变量已是静态常量，由于接口没有构造方法，所以必须显示赋值，可以直接用接口名访问。

# 匿名对象

一、匿名对象是指创建对象时，只有创建对象的语句，却没有把对象地址值赋值给某个变量。

二、特点

1. 只能使用一次
2. 可以作为方法的接受参、方法返回值使用。

# 内部类

一、写在其他类的内部。

二、内部类的分类

1. 成员内部类
   - 定义在外部类中的成员位置。与类中的成员变量相似，可通过外部类对象进行访问
   - 外部类名.内部类名 变量名 = new 外部类名().new 内部类名();
2. 局部内部类
   - 定义在外部类方法中的局部位置。与访问方法中的局部变量相似，可通过调用方法进行访问
   - 访问方式：在外部类方法中，创建内部类对象，进行访问

```java
//定义类
class Party {//外部类，聚会
    public void puffBall() {// 吹气球方法
        class Ball {// 内部类，气球
            public void puff() {
                System.out.println("气球膨胀了");
            }
        }
    //创建内部类对象，调用puff方法
        new Ball().puff();
    }
}

    //访问内部类
    public static void main(String[] args) {
    //创建外部类对象
        Party p = new Party();
    //调用外部类中的puffBall方法
        p.puffBall();
    }
```

三、内部类的实际使用

1. 匿名内部类是创建某个类型子类对象的快捷方式。

```java
//已经存在的父类：
public abstract class Person{
    public abstract void eat();
}
    //定义并创建该父类的子类对象，并用多态的方式赋值给父类引用变量
    Person p = new Person(){
        public void eat() {
            System.out.println(“我吃了”);
        }
    };
//调用eat方法
p.eat();
```

# 包	

一、访问修饰符

1. public
2. provide
3. default
4. private

# 代码块

一、分类

1. 局部代码块
   - 定义在方法或语句中。
2. 构造代码块
   - 优先于构造方法执行，构造代码块用于执行所有对象均需要的初始化动作
   - 每创建一个对象均会执行一次构造代码块
3. 静态代码块
   - 它优先于主方法执行、优先于构造代码块执行，当以任意形式第一次使用到该类时执行。
   - 该类不管创建多少对象，静态代码块只执行一次。
   - 可用于给静态变量赋值，用来给类进行初始化。